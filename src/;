#include <memory>
#include <random>
#include <vector>
#include "renderer.h"
#include "shapes.h"
#include <unordered_set>
#include <queue>
#include "transform.h"
// collisionDetection
// Playfield 
//
// build a recipe builder
// goes through 
//
class CollisionShape {
public:
    CollisionShape();
    Transform2D* transform = nullptr;
    std::string name;
    virtual bool intersects(CollisionShape& other) = 0;
    //void updatePosition(Vector2D newPosition);
};

class RectCollisionShape : public CollisionShape{
    public: 
        RectCollisionShape(); 
        
        bool intersects(CollisionShape& other) override; 
};
class Collider {
    
    public: 
    CollisionShape* shape = nullptr;
    bool collision(Collider& other);
    bool getCollisionStatus();   
    
private:
    bool _hasCollided = false;


class Collisionhandler {

    std::vector<Collider*> colliders;

    void addCollider(Collider* c);
};

class GameObject {
public:    
    GameObject();
    GameObject(Vector2D pos);
    
    Transform2D* transform;
    Vector2D velocity{0.0f,0.0f}; // should be part of a physics class (like rigid body) for final engine,so don'lt couple to heavily  
    Graphic* graphic = nullptr;
    Collider* collider = new Collider();
    void move(Vector2D offset); 
    void applyVelocity();
     
};

class GameObjectFactory {
    GameObject createGameObject();
};

class GameHandler {
public: 
    GameHandler();
    Renderer* mainRender = nullptr;
    GraphicsFactory *factory = nullptr;
    std::vector<GameObject> gameObjects; 
    void addGameobject(/*blueprint here*/);
    GameObject* addGameobjectAt(Vector2D position); 
    void addArrow();  
    void updateObjects();

};
       
